from fastapi import Depends, HTTPException
from sqlalchemy.orm import Session
from sqlalchemy import text

from server.app import app

from server.database.connection import get_db
from server.database.models import ExploitBase, Exploit

@app.get("/exploits")
def get_exploits(db: Session = Depends(get_db)):
    result = db.execute(text("SELECT * FROM exploits")).fetchall()
    result = [Exploit.from_orm(exploit) for exploit in result]

    return result

@app.get("/exploits/{exploit_id}")
def get_exploits(exploit_id: int, db: Session = Depends(get_db)):
    result = db.execute(text("SELECT * FROM exploits WHERE id = :exploit_id"), { "exploit_id": exploit_id }).fetchone()

    if not result:
        raise HTTPException(404, "Not found")

    return Exploit.from_orm(result)

@app.post("/exploits")
def add_exploit(exploit: ExploitBase, db: Session = Depends(get_db)):
    db.execute(text("INSERT INTO exploits (name, threads, timeout, source, running) VALUES (:name, :threads, :timeout, :source, :running)"), { "name": exploit.name, "threads": exploit.threads, "timeout": exploit.timeout, "source": exploit.source, "running": exploit.running })
    db.commit()

    return exploit

@app.patch("/teams/{exploit_id}")
def edit_exploit(exploit_id: int, exploit: ExploitBase, db: Session = Depends(get_db)):
    db.execute(text("UPDATE exploits SET name = :name, threads = :threads, timeout = :timeout, source = :source WHERE id = :exploit_id"), { "name": exploit.name, "threads": exploit.threads, "timeout": exploit.timeout, "source": exploit.source, "running": exploit.running, "exploit_id": exploit_id })
    db.commit()

    #ExploitRunner().update_list()

    return exploit

@app.delete("/teams/{team_id}")
def delete_team(exploit_id: int, db: Session = Depends(get_db)):
    db.execute(text("DELETE FROM exploits WHERE id = :id"), { "id" : exploit_id })
    db.commit()

    return exploit_id

#@app.route('/exploits/<int:eid>', methods=['GET'])
## @auth.auth_required
#def exploit(eid):
#    # database.query("INSERT INTO exploits VALUES (1, 'asd', 123, 21, 'lol')")
#    # database.query("INSERT INTO exploits VALUES (2, 'asd', 123, 21, 'lol')")
#    #
#    # database.query("INSERT INTO teams VALUES (1, 'asd', 'lol')")
#    # database.query("INSERT INTO teams VALUES (2, 'asd', 'lol')")
#    #
#    # database.query("INSERT INTO exploit_teams VALUES (1, 1)")
#    # database.get().commit()
#
#    teams = connection.query("SELECT * FROM teams")
#    teams = [{"id": item["id"], "name": item["name"], "ip": item["ip"]}
#             for item in teams]
#
#    selectedTeams = connection.query(
#        "SELECT * FROM exploit_teams INNER JOIN teams ON exploit_teams.team_id = teams.id WHERE exploit_teams.exploit_id = %s", (eid,))
#    selectedTeams = [item["id"] for item in selectedTeams]
#
#    exploits = connection.query("SELECT * FROM exploits")
#    exploits = [{"id": item["id"], "name": item["name"], "threads": item["threads"],
#                 "timeout": item["timeout"], "source": item["source"], "running": int(item["running"]) == 1} for item in exploits]
#
#    try:
#        selectedExploit = next(
#            filter(lambda item: item["id"] == eid, exploits))
#    except:
#        selectedExploit = None
#
#    return render_template('exploits.html', exploits=exploits, teams=teams, eid=eid if selectedExploit != None else None, selectedTeams=selectedTeams, selectedExploit=selectedExploit)