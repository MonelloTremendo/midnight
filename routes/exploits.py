from fastapi import APIRouter, Depends
from fastapi.responses import JSONResponse
from sqlalchemy.orm import Session
from sqlalchemy import text

from typing import List

from routes.websocket import manager
import asyncio

from database.connection import get_db
from database.models import ExploitBase, Exploit, ExploitStatus, ExploitTeams

from runner.runner import run_exploit, stop_exploit, update_exploit, is_running

router = APIRouter(
    prefix="/exploits",
    tags=["exploits"],
    responses={404: {"description": "Not found"}},
)


@router.get("/")
def get_exploits(db: Session = Depends(get_db)) -> List[Exploit]:
    result = db.execute(text("SELECT * FROM exploits")).fetchall()
    result = [Exploit.from_orm(exploit) for exploit in result]

    return result


@router.get("/state")
def get_exploits(db: Session = Depends(get_db)) -> List[dict]:
    result = db.execute(text("SELECT id FROM exploits")).fetchall()
    result = [{"id": exploit[0], "status": 1 if is_running(exploit[0]) else 0 } for exploit in result]

    return result

@router.get("/teams")
def get_exploits_teams(db: Session = Depends(get_db)):
    out = dict()
    result = db.execute(text("SELECT id FROM exploits")).fetchall()

    for exploit in result:
        teams = db.execute(text("SELECT exploit_teams.team_id FROM exploit_teams WHERE exploit_teams.exploit_id = :exploit_id"), { "exploit_id": exploit[0] }).fetchall()
        teams = [team[0] for team in teams]
        out[exploit[0]] = teams

    return out


@router.get("/{exploit_id}")
def get_exploit(exploit_id: int, db: Session = Depends(get_db)) -> Exploit:
    result = db.execute(text("SELECT * FROM exploits WHERE id = :exploit_id"), { "exploit_id": exploit_id }).fetchone()

    if not result:
        return JSONResponse(status_code=404, content={"message": "exploit not found"})

    return Exploit.from_orm(result)


@router.get("/{exploit_id}/teams")
def get_exploit_teams(exploit_id: int, db: Session = Depends(get_db)) -> List[int]:
    result = db.execute(text("SELECT teams.id FROM exploit_teams INNER JOIN teams ON exploit_teams.team_id = teams.id WHERE exploit_teams.exploit_id = :exploit_id"), { "exploit_id": exploit_id }).fetchall()
    result = [team[0] for team in result]

    return result


@router.get("/{exploit_id}/state")
def get_exploit_state(exploit_id: int) -> ExploitStatus:
    return 1 if is_running(exploit_id) else 0


@router.post("/")
def add_exploit(exploit: ExploitBase, db: Session = Depends(get_db)) -> int:
    result = db.execute(text("INSERT INTO exploits (name, threads, timeout, runperiod, source) VALUES (:name, :threads, :timeout, :runperiod, :source)"), exploit.dict())
    db.commit()

    asyncio.run(manager.broadcast(f"exploit/{result.lastrowid}/new"))

    return result.lastrowid


@router.put("/{exploit_id}/state")
def edit_exploit_state(exploit_id: int, status: ExploitStatus) -> None:
    if status == 1:
        run_exploit(exploit_id)
    else:
        stop_exploit(exploit_id)

    asyncio.run(manager.broadcast(f"exploit/{exploit_id}/state"))

    return


@router.patch("/{exploit_id}")
def edit_exploit(exploit_id: int, exploit: ExploitBase, db: Session = Depends(get_db)) -> None:
    db.execute(text("UPDATE exploits SET name = :name, threads = :threads, timeout = :timeout, runperiod = :runperiod, source = :source WHERE id = :exploit_id"), { **exploit.dict(), "exploit_id": exploit_id })
    db.commit()

    update_exploit(exploit_id)

    asyncio.run(manager.broadcast(f"exploit/{exploit_id}/edit"))

    return


@router.patch("/{exploit_id}/teams")
def edit_exploit_teams(exploit_id: int, teams: ExploitTeams, db: Session = Depends(get_db)) -> None:
    db.execute(text("DELETE FROM exploit_teams WHERE exploit_id = :exploit_id"), { "exploit_id": exploit_id })

    for team in teams.ids:
        db.execute(text("INSERT INTO exploit_teams VALUES (:exploit_id, :team_id)"), { "exploit_id": exploit_id, "team_id": team })

    db.commit()

    update_exploit(exploit_id)

    asyncio.run(manager.broadcast(f"exploit/{exploit_id}/edit"))

    return


@router.delete("/{exploit_id}")
def delete_exploit(exploit_id: int, db: Session = Depends(get_db)) -> int:
    stop_exploit(exploit_id)

    db.execute(text("DELETE FROM exploits WHERE id = :exploit_id"), { "exploit_id" : exploit_id })
    db.commit()

    asyncio.run(manager.broadcast(f"exploit/{exploit_id}/del"))

    return exploit_id