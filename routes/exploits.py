from fastapi import APIRouter, Depends
from fastapi.responses import JSONResponse
from sqlalchemy.orm import Session
from sqlalchemy import text

#from server.router import router

from ..database.connection import get_db
from ..database.models import ExploitBase, Exploit, ExploitStatus, ExploitTeams

from ..runner.runner import run_exploit, stop_exploit, update_exploit

router = APIRouter(
    prefix="/exploits",
    tags=["exploits"],
    responses={404: {"description": "Not found"}},
)

@router.get("/")
def get_exploits(db: Session = Depends(get_db)):
    result = db.execute(text("SELECT * FROM exploits")).fetchall()
    result = [Exploit.from_orm(exploit) for exploit in result]

    return result

@router.get("/{exploit_id}")
def get_exploit(exploit_id: int, db: Session = Depends(get_db)):
    result = db.execute(text("SELECT * FROM exploits WHERE id = :exploit_id"), { "exploit_id": exploit_id }).fetchone()

    if not result:
        return JSONResponse(status_code=404, content={"message": "exploit not found"})

    return Exploit.from_orm(result)

@router.get("/{exploit_id}/teams")
def get_exploit_teams(exploit_id: int, db: Session = Depends(get_db)):
    result = db.execute(text("SELECT teams.id FROM exploit_teams INNER JOIN teams ON exploit_teams.team_id = teams.id WHERE exploit_teams.exploit_id = :exploit_id"), { "exploit_id": exploit_id }).fetchall()
    print(result)
    result = [team[0] for team in result]

    return result

@router.get("/{exploit_id}/state")
def get_exploit(exploit_id: int, db: Session = Depends(get_db)):
    result = db.execute(text("SELECT running FROM exploits WHERE id = :exploit_id"), { "exploit_id": exploit_id }).fetchone()

    if not result:
        return JSONResponse(status_code=404, content={"message": "exploit not found"})

    return result["running"]

@router.post("/")
def add_exploit(exploit: ExploitBase, db: Session = Depends(get_db)):
    result = db.execute(text("INSERT INTO exploits (name, threads, timeout, source) VALUES (:name, :threads, :timeout, :source)"), { "name": exploit.name, "threads": exploit.threads, "timeout": exploit.timeout, "source": exploit.source })
    db.commit()

    return result.lastrowid

@router.put("/{exploit_id}/state")
def get_exploit(exploit_id: int, status: ExploitStatus, db: Session = Depends(get_db)):
    result = db.execute(text("UPDATE exploits SET running = :running WHERE id = :exploit_id"), { "exploit_id": exploit_id, "running": status }).fetchone()

    if status == 1:
        run_exploit(exploit_id)
    else:
        stop_exploit(exploit_id)

    return

@router.patch("/{exploit_id}")
def edit_exploit(exploit_id: int, exploit: ExploitBase, db: Session = Depends(get_db)):
    db.execute(text("UPDATE exploits SET name = :name, threads = :threads, timeout = :timeout, source = :source WHERE id = :exploit_id"), { "name": exploit.name, "threads": exploit.threads, "timeout": exploit.timeout, "source": exploit.source, "running": exploit.running, "exploit_id": exploit_id })
    db.commit()

    update_exploit(exploit_id)

    return

@router.patch("/{exploit_id}/teams")
def edit_exploit_teams(exploit_id: int, teams: ExploitTeams, db: Session = Depends(get_db)):
    db.execute(text("DELETE FROM exploit_teams WHERE exploit_id = :exploit_id"), { "exploit_id": exploit_id })

    for team in teams.ids:
        db.execute(text("INSERT INTO exploit_teams VALUES (:exploit_id, :team_id)"), { "exploit_id": exploit_id, "team_id": team })

    db.commit()

    update_exploit(exploit_id)

    return


@router.delete("/{exploit_id}")
def delete_team(exploit_id: int, db: Session = Depends(get_db)):
    db.execute(text("DELETE FROM exploits WHERE id = :exploit_id"), { "exploit_id" : exploit_id })
    db.commit()

    return exploit_id